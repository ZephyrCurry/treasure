### 幂等方案

使用幂等表，通过数据库唯一索引实现幂等



简单版的方案（不加上分库分表）

```java
@Idempotent(key = "#request.businessCode + '_INBOUND'", shardingKey = "#request.warehouseCode")
public void inbound(InboundRequest request) {...}


@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
    /** 幂等Key的SpEL表达式，例如 "#order.orderNo" */
    String key();
    /** 幂等有效期（秒），默认1小时 */
    long expire() default 3600L;
    /** 提示语 */
    String message() default "请求正在处理中，请稍后...";
}


@Aspect
@Component
public class IdempotentAspect {

    @Autowired
    private JdbcTemplate jdbcTemplate; // 借鉴 JdbcIdempotentManager 方案 
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Around("@annotation(idempotent)")
    public Object around(ProceedingJoinPoint joinPoint, Idempotent idempotent) throws Throwable {
        // 1. 解析 Key (模仿 IdempotentKeyGenerator [cite: 2])
        String lockKey = parseSpelKey(joinPoint, idempotent.key());
        
        // 2. 尝试抢占锁/插入记录 (利用数据库唯一索引保证原子性)
        // 对应 Jar 中的 JdbcIdempotentManager.select/insert 逻辑 
        boolean isLocked = tryLock(lockKey, idempotent.expire());
        
        if (!isLocked) {
          // 3. 插入失败，进入核心补全逻辑：判定是否过期 
            Map<String, Object> record = getRecord(tableName, lockKey);
            long expireTime = (long) record.get("expire_time");
            
            // --- 核心补全：过期判定 ---
            if (System.currentTimeMillis() > expireTime) {
                // 如果已过期，删除旧记录并重新尝试加锁
                deleteRecord(tableName, lockKey);
                if (!tryLock(tableName, lockKey, idempotent.expire())) {
                    throw new RuntimeException("并发冲突，请稍后重试");
                }
            } else {
                // 未过期，执行正常幂等逻辑
                String status = (String) record.get("status");
                if ("PROCESSING".equals(status)) {
                    throw new RuntimeException("请求正在处理中...");
                } else if ("SUCCESS".equals(status)) {
                    MethodSignature signature = (MethodSignature) joinPoint.getSignature();
                    return objectMapper.readValue((String) record.get("result"), signature.getReturnType());
                }
            }
        }

        try {
            // 4. 执行业务逻辑
            Object result = joinPoint.proceed();
            
            // 5. 更新状态为 SUCCESS 并存储结果
            updateToSuccess(lockKey, result);
            return result;
        } catch (Throwable e) {
            // 6. 异常处理：删除记录或置为 FAILED，允许重试
            deleteRecord(lockKey);
            throw e;
        }
    }

    // --- 核心辅助方法 ---

    private boolean tryLock(String key, long expire) {
        try {
            // 假设表结构包含：id_key (唯一索引), status, result, expire_time
            String sql = "INSERT INTO idempotent_record (id_key, status, expire_time) VALUES (?, 'PROCESSING', ?)";
            jdbcTemplate.update(sql, key, System.currentTimeMillis() + expire * 1000);
            return true;
        } catch (DuplicateKeyException e) {
            return false;
        }
    }

    private void updateToSuccess(String key, Object result) throws Exception {
        String jsonResult = objectMapper.writeValueAsString(result);
        String sql = "UPDATE idempotent_record SET status = 'SUCCESS', result = ? WHERE id_key = ?";
        jdbcTemplate.update(sql, jsonResult, key);
    }

    private String parseSpelKey(ProceedingJoinPoint joinPoint, String spel) {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        EvaluationContext context = new StandardEvaluationContext();
        Object[] args = joinPoint.getArgs();
        String[] paramNames = signature.getParameterNames();
        for (int i = 0; i < args.length; i++) {
            context.setVariable(paramNames[i], args[i]);
        }
        ExpressionParser parser = new SpelExpressionParser();
        return signature.getMethod().getName() + ":" + parser.parseExpression(spel).getValue(context, String.class);
    }
    
    private Map<String, Object> getRecord(String key) {
        return jdbcTemplate.queryForMap("SELECT status, result FROM idempotent_record WHERE id_key = ?", key);
    }

    private void deleteRecord(String key) {
        jdbcTemplate.update("DELETE FROM idempotent_record WHERE id_key = ?", key);
    }
}
```





复杂点的方案（加上分库分表：

```java
@Idempotent(key = "#request.businessCode + '_INBOUND'", shardingKey = "#request.warehouseCode")
public void inbound(InboundRequest request) {...}


@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
    
    /** 幂等表名，默认为 t_idempotent */
    String table() default "t_idempotent";

    /** 幂等Key SpEL表达式 */
    String key() default "";

    /** 分片键 SpEL表达式，用于计算分表后缀 */
    String shardingKey() default "";

    /** 自定义Key生成器的Bean名称 */
    String generator() default "";
    
    /** 补充：过期时间，通常配置在 Properties 中，这里为了方便演示加在注解上 */
    long expire() default 3600; 
}


@Aspect
@Component
public class IdempotentAspect {

    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    private ApplicationContext applicationContext; // 用于获取 generator Bean

    private final ObjectMapper objectMapper = new ObjectMapper();
    private final ExpressionParser parser = new SpelExpressionParser();

    @Around("@annotation(idempotent)")
    public Object around(ProceedingJoinPoint joinPoint, Idempotent idempotent) throws Throwable {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        
        // 1. 解析核心参数
        EvaluationContext spelContext = buildSpelContext(joinPoint);
        
        // A. 获取 Business Key
        String businessKey = resolveKey(idempotent, spelContext);
        
        // B. 获取 Sharding Key 并计算真实表名
        String realTableName = resolveTableName(idempotent, spelContext);

        // 2. 尝试加锁 (原子性插入)
        // 对应 JdbcIdempotentManager 的核心逻辑
        boolean locked = tryLock(realTableName, businessKey, idempotent.expire());

        if (!locked) {
            // 3. 锁竞争失败 -> 查询现有记录
            Map<String, Object> record = getRecord(realTableName, businessKey);
            
            // 状态机判断：PROCESSING(1) -> 抛异常; SUCCESS(2) -> 返回旧结果
            String status = (String) record.get("status");
            if ("PROCESSING".equals(status)) {
                throw new RuntimeException("WMS系统提示：该单据正在处理中，请勿重复提交！");
            } else if ("SUCCESS".equals(status)) {
                // 结果回放：反序列化
                String jsonResult = (String) record.get("result");
                // 难点：处理泛型返回类型
                Class<?> returnType = signature.getReturnType();
                return objectMapper.readValue(jsonResult, returnType);
            }
        }

        // 4. 执行业务逻辑
        Object result;
        try {
            result = joinPoint.proceed();
        } catch (Throwable e) {
            // 业务失败：删除锁或标记为 FAILED
            handleException(realTableName, businessKey, e);
            throw e;
        }

        // 5. 业务成功：更新状态和结果
        updateSuccess(realTableName, businessKey, result);
        
        return result;
    }

    // --- 核心辅助方法 ---

    /**
     * 解析 Key，优先使用 generator，其次使用 key 的 SpEL
     */
    private String resolveKey(Idempotent idempotent, EvaluationContext context) {
        if (!"".equals(idempotent.generator())) {
            // 对应 Jar 中的 IdempotentKeyGenerator 接口
            IdempotentKeyGenerator generator = applicationContext.getBean(idempotent.generator(), IdempotentKeyGenerator.class);
            return generator.generate(context); 
        }
        return parser.parseExpression(idempotent.key()).getValue(context, String.class);
    }

    /**
     * 计算真实表名（实现分表逻辑）
     * 逻辑：如果 shardingKey 存在，计算 Hash 路由到 t_idempotent_01 等表
     */
    private String resolveTableName(Idempotent idempotent, EvaluationContext context) {
        String originalTable = idempotent.table().isEmpty() ? "t_idempotent" : idempotent.table();
        
        if ("".equals(idempotent.shardingKey())) {
            return originalTable;
        }

        // 解析 ShardingKey 的值，例如 warehouseCode = "WH001"
        Object shardingVal = parser.parseExpression(idempotent.shardingKey()).getValue(context);
        
        // 简单分表策略：取 HashCode 模 10 (模拟10张分表)
        // 实际 Jar 包可能通过 SqlIdempotentMetaDataHolder 进行更复杂的 SQL 改写 
        long hash = Math.abs(shardingVal.hashCode());
        int tableIndex = (int) (hash % 10); 
        
        return originalTable + "_" + tableIndex; 
    }

    private boolean tryLock(String tableName, String key, long expireSeconds) {
        try {
            // 动态拼接表名 (注意防 SQL 注入，这里简化处理)
            String sql = String.format("INSERT INTO %s (id_key, status, expire_time) VALUES (?, 'PROCESSING', ?)", tableName);
            long expireAt = System.currentTimeMillis() + (expireSeconds * 1000);
            jdbcTemplate.update(sql, key, expireAt);
            return true;
        } catch (DuplicateKeyException e) {
            return false;
        }
    }
    
    private Map<String, Object> getRecord(String tableName, String key) {
        String sql = String.format("SELECT status, result FROM %s WHERE id_key = ?", tableName);
        return jdbcTemplate.queryForMap(sql, key);
    }

    private void updateSuccess(String tableName, String key, Object result) throws Exception {
        String json = objectMapper.writeValueAsString(result);
        String sql = String.format("UPDATE %s SET status = 'SUCCESS', result = ? WHERE id_key = ?", tableName);
        jdbcTemplate.update(sql, json, key);
    }

    private void handleException(String tableName, String key, Throwable e) {
        // 简单策略：直接删除，允许重试
        String sql = String.format("DELETE FROM %s WHERE id_key = ?", tableName);
        jdbcTemplate.update(sql, key);
    }

    private EvaluationContext buildSpelContext(ProceedingJoinPoint joinPoint) {
        StandardEvaluationContext context = new StandardEvaluationContext();
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        String[] paramNames = signature.getParameterNames();
        Object[] args = joinPoint.getArgs();
        
        // 将方法参数放入 Context，支持 #request.warehouseCode 这种写法
        for (int i = 0; i < args.length; i++) {
            context.setVariable(paramNames[i], args[i]);
        }
        return context;
    }
    
    // 模拟 Jar 包中的 Generator 接口
    public interface IdempotentKeyGenerator {
        String generate(EvaluationContext context);
    }
}
```



